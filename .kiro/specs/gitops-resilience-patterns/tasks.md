# Implementation Plan

- [x] 1. Create pre-commit validation infrastructure
  - [x] 1.1 Write kustomization build validation script
    - Create script to validate all kustomization.yaml files can build successfully
    - Add validation for resource compatibility and syntax
    - _Requirements: 5.1, 5.2_
  - [x] 1.2 Implement immutable field change detection tool
    - Build tool to detect changes to immutable Kubernetes fields
    - Create mapping of known immutable fields by resource type
    - _Requirements: 1.1, 1.3_
  - [x] 1.3 Create Git pre-commit hook configuration
    - Set up pre-commit framework with validation hooks
    - Configure automatic execution of validation scripts
    - _Requirements: 5.1, 8.1_
  - [x] 1.4 Test validation pipeline with sample changes
    - Create test cases for common breaking changes
    - Validate hook prevents problematic commits
    - _Requirements: 5.2, 8.2_

- [x] 2. Implement reconciliation health monitoring
  - [x] 2.1 Redesign monitoring stack with hybrid storage architecture
    - Clean up existing stuck monitoring resources and PVCs
    - Implement ephemeral core monitoring (Prometheus + Grafana) with emptyDir storage for immediate visibility
    - Create separate long-term monitoring tier using Longhorn for historical data retention
    - Ensure core monitoring remains operational during storage failures (bulletproof architecture)
    - Configure remote_write from ephemeral to persistent tier for data continuity
    - Design storage tiers in preparation for future KubeVirt workloads
    - _Requirements: 4.1, 4.2, Bulletproof Architecture_
  - [x] 2.2 Create Flux reconciliation metrics collection
    - Extend hybrid Prometheus setup to collect Flux-specific metrics
    - Add hybrid ServiceMonitor + PodMonitor for comprehensive Flux controller coverage
    - Document Flux controller architecture and monitoring implementation
    - _Requirements: 4.1, 4.2_
  - [x] 2.3 Write alert rules for stuck reconciliations
    - Create PrometheusRule for stuck kustomizations and failed reconciliations
    - Configure alert thresholds and escalation policies
    - _Requirements: 4.2, 4.3_
  - [x] 2.4 Build GitOps health monitoring dashboard
    - Create Grafana dashboard for Flux reconciliation visibility
    - Add panels for reconciliation timing, error rates, and resource status
    - _Requirements: 4.1, 4.4_
  - [x] 2.5 Test alerting with simulated stuck states
    - Create test scenarios to validate alert firing
    - Verify alert routing and notification delivery
    - _Requirements: 4.3, 4.4_

- [x] 3. Build automated recovery system for stuck reconciliations
  - [x] 3.1 Create error pattern detection system
    - Build controller to monitor Flux events and classify error patterns
    - Implement pattern matching for common failure scenarios
    - _Requirements: 3.1, 3.2_
  - [x] 3.2 Implement resource recreation automation
    - Create automation for handling immutable field conflicts
    - Build safe resource replacement procedures
    - _Requirements: 1.1, 3.2_
  - [x] 3.3 Build dependency-aware cleanup procedures
    - Implement dependency graph analysis for resource cleanup
    - Create ordered cleanup and recreation workflows
    - _Requirements: 3.3, 6.2_
  - [x] 3.4 Write recovery orchestration controller
    - Build Kubernetes controller to orchestrate recovery procedures
    - Implement recovery state tracking and retry logic
    - _Requirements: 3.1, 3.4_

- [x] 4. Establish emergency recovery procedures and tooling
  - [x] 4.1 Document manual recovery procedures for common failure scenarios
    - Comprehensive Flux recovery guide already exists in docs/troubleshooting/
    - Covers namespace stuck states, authentication failures, and controller recovery
    - _Requirements: 7.1, 7.2_
  - [x] 4.2 Create emergency tooling for force cleanup of stuck resources
    - Build CLI tools for emergency resource cleanup
    - Create scripts for namespace finalizer removal and forced deletion
    - _Requirements: 7.2, 7.3_
  - [ ] 4.3 Build system state backup and restore capabilities
    - Implement automated backup of Flux configurations and cluster state
    - Create restore procedures for critical system components
    - Include Longhorn volume backup integration (see docs/longhorn-monitoring-requirements.md)
    - _Requirements: 7.3, 7.4_
  - [x] 4.4 Write runbooks for escalation scenarios
    - Escalation procedures documented in existing recovery guide
    - Includes troubleshooting steps and verification checklists
    - _Requirements: 7.1, 7.4_

- [ ] 5. Implement resource lifecycle management patterns
  - [ ] 5.1 Create blue-green deployment strategy for immutable resources
    - Implement blue-green patterns for Deployments with immutable selectors
    - Create tooling for atomic resource replacement
    - _Requirements: 1.1, 2.1_
  - [ ] 5.2 Build atomic resource replacement tooling
    - Create utilities for safe resource recreation with zero downtime
    - Implement validation and rollback mechanisms
    - _Requirements: 2.2, 6.1_
  - [x] 5.3 Implement dependency-aware update ordering
    - Build system to analyze and order resource updates by dependencies
    - Create update orchestration with proper sequencing
    - _Requirements: 2.3, 6.2_
  - [ ] 5.4 Write resource update strategy annotation framework
    - Define annotation schema for resource update strategies
    - Implement strategy selection and execution logic
    - _Requirements: 2.4, 6.3_

- [ ] 6. Build change impact analysis system
  - [x] 6.1 Create resource dependency mapping tools
    - Build tools to analyze and visualize resource dependencies
    - Create dependency graph generation and analysis
    - _Requirements: 8.1, 8.3_
  - [ ] 6.2 Implement breaking change detection
    - Create validation for infrastructure changes that could break existing resources
    - Build compatibility checking between resource versions
    - _Requirements: 8.2, 8.4_
  - [ ] 6.3 Build cascade effect analysis
    - Implement analysis of downstream effects from resource changes
    - Create impact assessment and risk scoring
    - _Requirements: 8.3, 8.4_
  - [ ] 6.4 Write risk assessment automation
    - Build automated risk assessment for proposed infrastructure changes
    - Create approval workflows for high-risk changes
    - _Requirements: 8.1, 8.4_

- [ ] 7. Create staged deployment validation pipeline
  - [ ] 7.1 Implement dry-run testing automation
    - Create automated dry-run validation for all infrastructure changes
    - Build CI/CD integration for pre-deployment validation
    - _Requirements: 5.1, 5.3_
  - [ ] 7.2 Build compatibility validation system
    - Create validation between old and new resource definitions
    - Implement compatibility checking for breaking changes
    - _Requirements: 5.2, 5.4_
  - [ ] 7.3 Create staged rollout controller
    - Build Kubernetes controller for staged infrastructure deployments
    - Implement canary deployment patterns for infrastructure
    - _Requirements: 5.3, 5.4_
  - [ ] 7.4 Write validation gate system
    - Create validation gates and approval workflows for deployment progression
    - Implement automated rollback on validation failures
    - _Requirements: 5.1, 5.4_

- [ ] 8. Establish resource state consistency mechanisms
  - [ ] 8.1 Implement atomic operation patterns
    - Create patterns for atomic multi-resource updates
    - Build transaction-like behavior for complex changes
    - _Requirements: 6.1, 6.2_
  - [ ] 8.2 Build state consistency validation tools
    - Create tools to validate and repair inconsistent resource states
    - Implement consistency checking across resource dependencies
    - _Requirements: 6.3, 6.4_
  - [ ] 8.3 Create conflict resolution system
    - Build automated conflict resolution with prioritization rules
    - Implement conflict detection and resolution strategies
    - _Requirements: 6.2, 6.4_
  - [ ] 8.4 Write state repair automation
    - Create automation to detect and repair inconsistent states
    - Build self-healing mechanisms for common state issues
    - _Requirements: 6.1, 6.3_

- [ ] 9. Build comprehensive testing and validation framework (UNIFIED FRAMEWORK)
  - [ ] 9.1 Create chaos engineering test suite
    - Build test suite to validate GitOps resilience under failure conditions
    - Implement automated chaos testing scenarios
    - Include storage failure scenarios (Longhorn integration)
    - _Requirements: 3.4, 7.4_
  - [ ] 9.2 Implement automated recovery testing
    - Create automated tests for all recovery procedures
    - Build validation of recovery effectiveness and timing
    - Include monitoring system recovery testing (from Monitoring spec Task 8)
    - _Requirements: 3.4, 7.2_
  - [ ] 9.3 Build end-to-end reconciliation tests
    - Create integration tests for complete reconciliation scenarios
    - Implement testing of complex multi-resource deployments
    - _Requirements: 5.4, 6.4_
  - [ ] 9.4 Write performance testing for failure conditions
    - Build performance tests for system behavior under various failure modes
    - Create load testing for recovery procedures
    - _Requirements: 3.4, 4.4_
  - _Note: This is the UNIFIED testing framework that other specs integrate with_

- [x] 10. Create operational dashboards and documentation
  - [x] 10.1 Build comprehensive GitOps health monitoring dashboard
    - Extend existing Grafana setup with GitOps-specific dashboards
    - Create visualizations for reconciliation health and performance
    - _Requirements: 4.1, 4.4_
  - [ ] 10.2 Create automated incident response procedures
    - Build automated incident detection and response workflows
    - Implement escalation and notification automation
    - _Requirements: 4.3, 7.1_
  - [x] 10.3 Write operational runbooks and troubleshooting guides
    - Comprehensive troubleshooting guide already exists
    - Covers common scenarios and resolution procedures
    - Added comprehensive testing documentation and validation tools
    - Created automated health check scripts for post-outage validation
    - _Requirements: 7.1, 7.4_
  - [ ] 10.4 Implement continuous improvement feedback collection
    - Create metrics collection for recovery effectiveness
    - Build feedback loops for improving resilience patterns
    - _Requirements: 4.4, 7.4_

- [ ] 11. Code Quality and Documentation Improvements
  - [ ] 11.0 Improve archive documentation structure and consistency **[NEW - DOCUMENTATION QUALITY ISSUES]**
    - **INCONSISTENT FORMAT**: Standardize archive entry format across all entries in docs/archive/README.md (lines 19-32 use different structure than existing entries)
    - **CONTENT REDUNDANCY**: Consolidate repetitive "Development artifact" reasoning into more specific categories to reduce duplication
    - **MISSING METADATA**: Add structured metadata fields (creation date, file size, dependencies, retention period) for better archive management
    - **VAGUE POLICY**: Create specific archival criteria with measurable thresholds, timeframes, and clear distinction between temporary vs. permanent archival
    - **MAINTENANCE BURDEN**: Current inconsistent format makes it harder to programmatically process or validate archive entries
    - **USER EXPERIENCE**: Inconsistent documentation structure confuses users trying to understand archive organization
    - _Requirements: Documentation Quality, Consistency, Maintainability, User Experience_
  - [ ] 11.1 Improve documentation reorganization plan quality **[NEW - DOCUMENTATION ARCHITECTURE ISSUES]**
    - **STRUCTURE DESIGN**: Simplify over-engineered 6-folder structure to 3-4 folders initially for homelab context
    - **NAMING CONSISTENCY**: Standardize folder naming convention (all plural vs singular) - currently mixed
    - **CONTENT BOUNDARIES**: Define clearer scope boundaries between setup/, user-guides/, and operations/ folders
    - **DUPLICATION RISK**: Create content audit matrix to prevent duplicate information across multiple folders
    - **MIGRATION SAFETY**: Add explicit backup and rollback procedures before high-risk Phase 3 cleanup
    - **VALIDATION MISSING**: Add validation checklists and success criteria for each migration phase
    - **MAINTENANCE MODEL**: Define documentation ownership and review cycles for new structure
    - **AUTOMATION GAPS**: Include automated link checking and content validation tools in migration plan
    - **USER FEEDBACK**: Add user testing or feedback collection mechanism to validate new structure
    - **NAVIGATION AIDS**: Plan for breadcrumbs, cross-references, and site map to prevent user confusion
    - _Requirements: Documentation Architecture, User Experience, Maintainability, Risk Management_
  - [ ] 11.1 Fix error pattern detection testing documentation accuracy
    - Correct inaccurate test descriptions in docs/testing/error-pattern-detection-testing.md
    - Align documentation claims with actual test script capabilities
    - Add realistic success indicators that match script functionality
    - Include comprehensive troubleshooting for script dependencies and failure modes
    - Simplify overly complex documentation structure while maintaining essential information
    - Add missing documentation about test environment prerequisites
    - _Requirements: Documentation Quality, User Experience, Accuracy_
  - [ ] 11.1.1 Improve monitoring user guide documentation quality **[HIGH PRIORITY - DOCUMENTATION QUALITY ISSUES]**
    - **CRITICAL USER IMPACT**: This is the first link in the new docs/README.md Quick Start section - quality issues here will frustrate users immediately
    - **CONSISTENCY**: Fix inconsistent command examples - some use `<name>` placeholder, others use `<n>` (line 148)
    - **MAINTAINABILITY**: Extract repeated kubectl port-forward commands into reusable code blocks to reduce duplication (lines 11-12, 21-22, 198, 225, 270)
    - **ACCURACY**: Validate all script references exist and work as documented (./scripts/monitoring-health-check.sh, ./scripts/cleanup-stuck-monitoring.sh)
    - **USABILITY**: Add error handling guidance for common port-forward failures (port already in use, context not found)
    - **SECURITY**: Remove hardcoded credentials reference and point to secure credential retrieval methods (line 40)
    - **COMPLETENESS**: Add missing troubleshooting steps for when Tailscale context doesn't exist or auth fails
    - **ORGANIZATION**: Create consistent section structure - some sections have subsections, others don't follow the same pattern
    - **VALIDATION**: Add verification steps after each major operation to confirm success before proceeding
    - **CROSS-REFERENCES**: Ensure all referenced files and scripts actually exist in the repository structure
    - **PLATFORM-SPECIFIC**: Add Windows/Linux alternatives to macOS-specific commands like `open` and `pkill`
    - _Requirements: Documentation Quality, User Experience, Accuracy, Cross-Platform Support_
  - [ ] 11.1.2 Validate documentation cross-references in new docs/README.md **[NEW - LINK VALIDATION]**
    - **BROKEN LINK PREVENTION**: Verify all files referenced in Quick Start section exist and are accessible
    - **SCRIPT VALIDATION**: Confirm emergency CLI script and health check scripts work as documented
    - **CONTENT ACCURACY**: Ensure referenced guides match their descriptions in the README
    - **USER JOURNEY TESTING**: Test the complete user flow from README through referenced guides
    - **MAINTENANCE AUTOMATION**: Add automated link checking to prevent future broken references
    - _Requirements: Documentation Quality, User Experience, Link Integrity_
  - [ ] 11.2 Improve pre-commit documentation accuracy
    - Fix inconsistent validation step descriptions between docs and implementation
    - Add detailed validation strategy explanations for each file type
    - Include specific recovery procedures for each validation step failure
    - Add coverage for additional file types (patch files, Helm values, SOPS encrypted)
    - _Requirements: Documentation Quality, User Experience_
  - [ ] 11.2 Enhance shell script robustness and consistency
    - Standardize error handling patterns across all validation scripts
    - Improve temporary file cleanup with robust trap handlers
    - Fix variable quoting inconsistencies
    - Add consistent `set -euo pipefail` usage
    - _Requirements: Code Quality, Maintainability_
  - [ ] 11.3 Improve dependency detection and messaging
    - Enhance dependency checking logic with clear impact explanations
    - Add specific installation hints for missing tools
    - Improve user feedback when optional dependencies are missing
    - Create tool availability checking with purpose descriptions
    - _Requirements: User Experience, Operational Excellence_
  - [ ] 11.4 Optimize validation performance
    - Add parallel processing option for immutable field checking
    - Implement configurable job limits for large repositories
    - Optimize resource processing loops for better performance
    - Add progress indicators for long-running validations
    - _Requirements: Performance, Scalability_
  - [ ] 11.5 Enhance error message quality and actionability
    - Replace generic error messages with specific, actionable guidance
    - Add suggested remediation commands for common failures
    - Include context about why changes would cause issues
    - Provide clear next steps for each type of validation failure
    - _Requirements: User Experience, Troubleshooting_
  - [ ] 11.6 Strengthen validation script architecture
    - Implement consistent logging framework across all scripts
    - Add configuration file support for validation settings
    - Create modular validation functions for better maintainability
    - Add comprehensive test coverage for validation logic
    - _Requirements: Code Quality, Maintainability, Testing_
  - [ ] 11.7 Refactor runtime test script for better maintainability
    - Extract common kubectl operations into reusable functions to reduce code duplication
    - Implement proper error handling with detailed failure context and recovery suggestions
    - Add configurable timeouts and retry logic for flaky Kubernetes operations
    - Create modular test framework with setup/teardown phases and test isolation
    - Improve resource cleanup with comprehensive trap handlers and cleanup verification
    - Add parallel test execution capability with proper synchronization
    - Implement test result persistence and detailed reporting with failure analysis
    - _Requirements: Code Quality, Maintainability, Testing, Reliability_
  - [ ] 11.8 Refactor emergency CLI scripts for improved maintainability and robustness (OWNS EMERGENCY CLI)
    - **CRITICAL CODE SMELLS**: Extract duplicated kubectl command patterns into reusable functions (emergency-cli.sh lines 95-98, 110-113, emergency-cleanup.sh lines 180-190, 220-230)
    - **PERFORMANCE ISSUE**: Replace inefficient while-loop parsing with proper array handling for resource lists (emergency-cleanup.sh lines 140-150, 200-210, 280-290)
    - **MAINTAINABILITY**: Create shared configuration module for common constants (colors, timeouts, paths) duplicated across both scripts
    - **ERROR HANDLING**: Implement consistent error recovery patterns with proper cleanup in trap handlers for interrupted operations
    - **SECURITY**: Add input validation and sanitization for user-provided resource names and namespaces to prevent injection attacks
    - **RELIABILITY**: Replace fragile text parsing with structured JSON output from kubectl commands using -o jsonpath consistently
    - **CODE ORGANIZATION**: Extract complex functions (show_status, comprehensive_cleanup) into separate modules for better testability
    - **LOGGING**: Standardize logging format and add structured logging with severity levels and operation context
    - **CONFIGURATION**: Add configuration file support for default timeouts, backup retention, and operation preferences
    - **TESTING**: Create unit test framework for individual functions using bash testing tools (bats or similar)
    - **EXTENSIBILITY**: Create plugin architecture for other specs to add domain-specific commands (monitoring, storage, etc.)
    - _Requirements: Code Quality, Maintainability, Security, Reliability, Performance_
    - _Note: This task OWNS the emergency CLI - other specs add features after this refactoring_
  - [ ] 11.10 Refactor update orchestrator CLI script for improved maintainability and robustness **[NEW - CRITICAL CODE QUALITY ISSUES]**
    - **CRITICAL ARCHITECTURE**: Monolithic main() function with 100+ lines violates Single Responsibility Principle - extract command routing, argument parsing, and execution logic into separate functions
    - **CRITICAL ERROR HANDLING**: Inconsistent exit code usage - functions return 0/1 but script uses exit codes 0-4 documented in usage, creating mismatch between documentation and implementation
    - **HIGH CODE DUPLICATION**: Python command building pattern repeated 6+ times across functions (lines 200-220, 250-270, 300-320, etc.) - extract into reusable build_python_command() function
    - **HIGH MAINTAINABILITY**: Complex argument parsing logic mixed with command execution in main() - separate into parse_global_args() and route_command() functions
    - **HIGH RELIABILITY**: No validation of Python script existence or executability before building commands - could fail silently with confusing error messages
    - **MEDIUM PERFORMANCE**: Inefficient resource loading with multiple file operations and temporary file creation - optimize with streaming or in-memory processing where possible
    - **MEDIUM SECURITY**: No input sanitization for file paths and resource specifications - potential path traversal vulnerability in load_resources() function
    - **MEDIUM TESTABILITY**: Hard-coded paths and direct Python subprocess calls make unit testing difficult - needs dependency injection pattern
    - **LOW CONSISTENCY**: Mixed error handling patterns - some functions use return codes, others use exit, some print errors before returning
    - **LOW DOCUMENTATION**: Complex functions like load_resources() and show_plan_summary() lack inline documentation explaining their logic flow
    - **DESIGN PATTERN**: Should implement Command pattern for different operations (plan, execute, validate, etc.) to improve extensibility and testing
    - **DESIGN PATTERN**: Should implement Strategy pattern for different resource loading methods (file, directory, kustomization, stdin)
    - _Requirements: Code Quality, Maintainability, Security, Reliability, Performance, Testability_
  - [ ] 11.9 Refactor dependency analyzer script for improved code quality and maintainability **[NEW - PYTHON CODE QUALITY ISSUES]**
    - **CRITICAL ARCHITECTURE**: Missing proper error handling for subprocess calls - kubectl commands can fail silently (lines 85-95, 105-115)
    - **CRITICAL PERFORMANCE**: Inefficient resource loading - loads ALL cluster resources regardless of analysis scope (lines 75-105)
    - **HIGH MAINTAINABILITY**: Monolithic class with 400+ lines - violates Single Responsibility Principle, should be split into ResourceLoader, DependencyExtractor, GraphAnalyzer, ReportGenerator
    - **HIGH CODE SMELL**: Complex nested loops and conditionals in _analyze_spec_references method (lines 180-280) - needs extraction into smaller, focused methods
    - **HIGH RELIABILITY**: No validation of loaded YAML documents - malformed YAML could cause silent failures or crashes (lines 125-135)
    - **MEDIUM PERFORMANCE**: Redundant graph traversal in impact/dependency chain analysis - could be optimized with memoization (lines 285-330)
    - **MEDIUM SECURITY**: No input sanitization for file paths and resource names - potential path traversal vulnerability (lines 115-125)
    - **MEDIUM TESTABILITY**: Hard-coded subprocess calls make unit testing difficult - needs dependency injection for kubectl interface
    - **LOW DOCUMENTATION**: Missing docstrings for complex private methods and unclear variable names (resource_ref vs other_ref)
    - **LOW CONSISTENCY**: Inconsistent error handling patterns - some methods print warnings, others raise exceptions, some fail silently
    - **DESIGN PATTERN**: Should implement Strategy pattern for different resource loading strategies (cluster vs manifest vs mixed)
    - **DESIGN PATTERN**: Should implement Observer pattern for progress reporting during long-running analysis operations
    - _Requirements: Code Quality, Maintainability, Performance, Security, Reliability, Testability_

- [ ] 12. Security Hardening and Secret Management **[URGENT - ACTIVE SECURITY BREACH]**
  - [ ] 12.1 Implement SOPS encryption for Tailscale secrets **[CRITICAL - SECURITY VULNERABILITY - ACTIVE]**
    - **IMMEDIATE ACTION REQUIRED**: A plaintext Tailscale auth key was committed to Git (key has been redacted and revoked)
    - **STEP 1**: Revoke the exposed auth key in Tailscale admin console immediately
    - **STEP 2**: Generate new auth key and encrypt with SOPS before committing
    - **STEP 3**: Remove plaintext credentials from Git history (git filter-branch or BFG)
    - **STEP 4**: Create encrypted secret templates for different environments
    - **STEP 5**: Add SOPS decryption to Flux Kustomization configurations
    - **STEP 6**: Document secret rotation procedures using encrypted storage
    - _Requirements: Security, Secret Management, GitOps Best Practices, Incident Response_
  - [ ] 12.2 Establish environment-specific secret isolation
    - Create separate Tailscale auth keys for dev/staging/prod environments
    - Implement per-environment secret namespacing and access controls
    - Add environment-specific Kustomize overlays for secret management
    - Document environment isolation strategy for sensitive credentials
    - _Requirements: Security, Environment Isolation, Access Control_
  - [ ] 12.5 Refactor Tailscale configuration for proper GitOps patterns **[HIGH PRIORITY - MULTIPLE ISSUES]**
    - **CRITICAL**: Pin Tailscale image to specific version tags instead of :latest (currently using latest tag)
    - **SECURITY**: Replace privileged init container with specific capability requirements (currently uses privileged: true)
    - **MAINTAINABILITY**: Create environment-specific overlays for network range configuration (hardcoded ranges in base)
    - **RELIABILITY**: Add proper health checks (liveness/readiness probes) to subnet router (currently missing)
    - **PERFORMANCE**: Implement configurable resource limits per environment (current limits may be insufficient)
    - **DOCUMENTATION**: Add comprehensive documentation for network range management and security model
    - **ARCHITECTURE**: Replace hardcoded network ranges with Kustomize patches per environment
    - _Requirements: Security, Maintainability, Environment Isolation, Best Practices, Reliability_
  - [ ] 12.6 Address specific Tailscale configuration code quality issues **[DETAILED ANALYSIS - UPDATED]**
    - **CRITICAL SECURITY**: Init container uses `privileged: true` (subnet-router.yaml:19) - replace with specific capabilities `CAP_NET_ADMIN` and `CAP_SYS_ADMIN`
    - **CRITICAL SECURITY**: Using `:latest` image tag (subnet-router.yaml:31) - pin to specific version like `tailscale/tailscale:v1.56.1`
    - **HIGH MAINTAINABILITY**: Hardcoded network ranges in base (subnet-router.yaml:50) - create environment-specific Kustomize patches for `TS_ROUTES`
    - **HIGH RELIABILITY**: Missing health checks - add liveness/readiness probes to detect Tailscale daemon failures and validate connectivity
    - **MEDIUM RESOURCE**: Current resource limits (100m CPU, 100Mi memory) may be insufficient - create environment-specific resource patches
    - **MEDIUM ARCHITECTURE**: No environment overlays - create dev/staging/prod overlay structure for proper environment isolation
    - **LOW DOCUMENTATION**: Missing inline comments explaining security model, network architecture, and capability requirements
    - **LOW TESTING**: No connectivity validation mechanism - add health check endpoints or validation scripts
    - _Requirements: Security, Reliability, Maintainability, Best Practices, Environment Isolation_
  - [ ] 12.3 Implement automated secret rotation strategy
    - Create tooling for automated Tailscale auth key rotation
    - Build secret lifecycle management with expiration tracking
    - Implement zero-downtime secret updates across environments
    - Add monitoring and alerting for secret expiration and rotation failures
    - Document emergency secret rotation procedures
    - _Requirements: Security, Automation, Operational Excellence_
  - [ ] 12.4 Add secret validation to pre-commit hooks
    - Extend pre-commit validation to detect plaintext secrets
    - Add checks for proper SOPS encryption of sensitive files
    - Implement secret format validation and compliance checking
    - Create automated remediation suggestions for secret violations
    - _Requirements: Security, Validation, Prevention_
  - [ ] 12.5 Refactor Tailscale configuration for proper GitOps patterns **[HIGH PRIORITY - MULTIPLE ISSUES]**
    - **CRITICAL**: Pin Tailscale image to specific version tags instead of :latest (currently using latest tag)
    - **SECURITY**: Replace privileged init container with specific capability requirements (currently uses privileged: true)
    - **MAINTAINABILITY**: Create environment-specific overlays for network range configuration (hardcoded ranges in base)
    - **RELIABILITY**: Add proper health checks (liveness/readiness probes) to subnet router (currently missing)
    - **PERFORMANCE**: Implement configurable resource limits per environment (current limits may be insufficient)
    - **DOCUMENTATION**: Add comprehensive documentation for network range management and security model
    - **ARCHITECTURE**: Replace hardcoded network ranges with Kustomize patches per environment
    - _Requirements: Security, Maintainability, Environment Isolation, Best Practices, Reliability_
  - [ ] 12.6 Address specific Tailscale configuration code quality issues **[DETAILED ANALYSIS - UPDATED]**
    - **CRITICAL SECURITY**: Init container uses `privileged: true` (subnet-router.yaml:19) - replace with specific capabilities `CAP_NET_ADMIN` and `CAP_SYS_ADMIN`
    - **CRITICAL SECURITY**: Using `:latest` image tag (subnet-router.yaml:31) - pin to specific version like `tailscale/tailscale:v1.56.1`
    - **HIGH MAINTAINABILITY**: Hardcoded network ranges in base (subnet-router.yaml:50) - create environment-specific Kustomize patches for `TS_ROUTES`
    - **HIGH RELIABILITY**: Missing health checks - add liveness/readiness probes to detect Tailscale daemon failures and validate connectivity
    - **MEDIUM RESOURCE**: Current resource limits (100m CPU, 100Mi memory) may be insufficient - create environment-specific resource patches
    - **MEDIUM ARCHITECTURE**: No environment overlays - create dev/staging/prod overlay structure for proper environment isolation
    - **LOW DOCUMENTATION**: Missing inline comments explaining security model, network architecture, and capability requirements
    - **LOW TESTING**: No connectivity validation mechanism - add health check endpoints or validation scripts
    - _Requirements: Security, Reliability, Maintainability, Best Practices, Environment Isolation_